/*
 * Copyright (C) 2013 Aurora Cain
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package edu.uncc.genosets.studyset.listview;

import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import javax.swing.JPanel;
import org.openide.explorer.ExplorerManager;
import org.openide.explorer.view.BeanTreeView;
import org.openide.nodes.AbstractNode;
import org.openide.nodes.ChildFactory;
import org.openide.nodes.Children;
import org.openide.nodes.Index;
import org.openide.nodes.Node;
import org.openide.nodes.NodeTransfer;
import org.openide.util.Exceptions;
import org.openide.util.Lookup;
import org.openide.util.datatransfer.PasteType;
import org.openide.util.lookup.Lookups;

public final class GroupHierarchyVisualPanel1 extends JPanel implements ExplorerManager.Provider {

    private final ExplorerManager em;
    List<HierarchyType> current; 
    List<HierarchyType> available; 

    /**
     * Creates new form GroupHierarchyVisualPanel1
     */
    public GroupHierarchyVisualPanel1(Map<String, GroupHierarchy> hierarchyMap) {
        this.em = new ExplorerManager();
        List<String> entityHierarchy = GroupHierarchy.getEntityHierarchy();
        GroupHierarchy featureHier = hierarchyMap.get("Feature");
        current = new ArrayList(entityHierarchy.size());
        available = new ArrayList(entityHierarchy.size());
        for (String string : entityHierarchy) {
            available.add(new HierarchyType(string));
        }
        for (String string : featureHier.getHierarchyList()) {
            current.add(new HierarchyType(string));
        }
        available.removeAll(current);
        initComponents();
    }

    @Override
    public String getName() {
        return "Step #1";
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new HierarchyListView(current);
        jPanel2 = new HierarchyListView(available);

        jPanel1.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 177, Short.MAX_VALUE)
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );

        jPanel2.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 189, Short.MAX_VALUE)
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 254, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 28, Short.MAX_VALUE)
                .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    // End of variables declaration//GEN-END:variables

    @Override
    public ExplorerManager getExplorerManager() {
        return this.em;
    }

    static class HierarchyListView extends JPanel implements ExplorerManager.Provider {

        private final ExplorerManager em;
        private BeanTreeView view;

        public HierarchyListView(List<HierarchyType> list) {
            this.em = new ExplorerManager();
            this.em.setRootContext(new RootNode(new HierarchyFactory(list)));
            view = new BeanTreeView();
            view.setRootVisible(false);
        }

        private void initComponents() {
            javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
            this.setLayout(layout);
            layout.setHorizontalGroup(
                    layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(view, javax.swing.GroupLayout.PREFERRED_SIZE, 311, javax.swing.GroupLayout.PREFERRED_SIZE));
            layout.setVerticalGroup(
                    layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(view, javax.swing.GroupLayout.DEFAULT_SIZE, 352, Short.MAX_VALUE));
        }

        @Override
        public void addNotify() {
            super.addNotify();
            initComponents();
        }

        @Override
        public ExplorerManager getExplorerManager() {
            return this.em;
        }
    }

    static class HierarchyType {

        private final String name;

        public HierarchyType(String name) {
            this.name = name;
        }

        public String getName() {
            return name;
        }

        @Override
        public int hashCode() {
            int hash = 3;
            hash = 29 * hash + (this.name != null ? this.name.hashCode() : 0);
            return hash;
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == null) {
                return false;
            }
            if (getClass() != obj.getClass()) {
                return false;
            }
            final HierarchyType other = (HierarchyType) obj;
            if ((this.name == null) ? (other.name != null) : !this.name.equals(other.name)) {
                return false;
            }
            return true;
        }
    }

    static class HierarchyFlavor extends DataFlavor {

        static final DataFlavor HIERARCHY_FLAVOR = new HierarchyFlavor();

        public HierarchyFlavor() {
            super(HierarchyType.class, "HierarchyType");
        }
    }

    static class RootNode extends AbstractNode {

        private final HierarchyFactory hierarchyFactory;

        public RootNode(HierarchyFactory children) {
            super(Children.create(children, false));
            this.setName("Root");
            this.hierarchyFactory = children;
            getCookieSet().add(new Index.Support() {
                @Override
                public Node[] getNodes() {
                    return getChildren().getNodes();
                }

                @Override
                public int getNodesCount() {
                    return getNodes().length;
                }

                @Override
                public void reorder(int[] perm) {
                    hierarchyFactory.reorder(perm);
                }
            });

        }

        @Override
        public Transferable drag() throws IOException {
            return super.drag();
        }

        @Override
        public PasteType getDropType(final Transferable t, int action, int index) {
            if (t.isDataFlavorSupported(HierarchyFlavor.HIERARCHY_FLAVOR)) {
                return new PasteType() {
                    @Override
                    public Transferable paste() throws IOException {
                        try {
                            hierarchyFactory.add((HierarchyType) t.getTransferData(HierarchyFlavor.HIERARCHY_FLAVOR));
                            final Node node = NodeTransfer.node(t, NodeTransfer.DND_COPY_OR_MOVE + NodeTransfer.DND_LINK + NodeTransfer.CLIPBOARD_CUT);
                            if (node != null) {
                                node.destroy();
                            }

                        } catch (UnsupportedFlavorException ex) {
                            Exceptions.printStackTrace(ex);
                        }
                        return null;
                    }
                };
            } else {
                return null;
            }
        }
    }

    static class HierarchyFactory extends ChildFactory<HierarchyType> {

        private final List<HierarchyType> hierarchy;

        public HierarchyFactory(List<HierarchyType> hierarchy) {
            this.hierarchy = hierarchy;
        }

        @Override
        protected boolean createKeys(List<HierarchyType> toPopulate) {
            toPopulate.addAll(hierarchy);
            return true;
        }

        @Override
        protected Node createNodeForKey(HierarchyType key) {
            return new HierarchyNode(key, Children.LEAF, Lookups.fixed(key));
        }

        private void reorder(int[] perm) {
            HierarchyType[] reordered = new HierarchyType[hierarchy.size()];
            for (int i = 0; i < perm.length; i++) {
                int j = perm[i];
                HierarchyType hier = hierarchy.get(i);
                reordered[j] = hier;
            }
            hierarchy.clear();
            hierarchy.addAll(Arrays.asList(reordered));
            refresh(true);
        }

        private void add(HierarchyType hierarchyType) {
            hierarchy.add(hierarchyType);
        }

        private void remove(HierarchyType hierarchyType) {
            hierarchy.remove(hierarchyType);
        }

        class HierarchyNode extends AbstractNode {

            public HierarchyNode(HierarchyType hierType, Children children, Lookup lookup) {
                super(children, lookup);
                this.setName(hierType.getName());
                this.setIconBaseWithExtension("edu/uncc/genosets/icons/no-icon.png");
            }

            @Override
            public boolean canDestroy() {
                return true;
            }

            @Override
            public boolean canCopy() {
                return true;
            }

            @Override
            public boolean canCut() {
                return true;
            }

            @Override
            public void destroy() throws IOException {
                remove(getLookup().lookup(HierarchyType.class));
            }

            @Override
            public Transferable drag() throws IOException {
                return super.drag();
            }

            @Override
            public PasteType getDropType(final Transferable t, int action, int index) {
                if (t.isDataFlavorSupported(HierarchyFlavor.HIERARCHY_FLAVOR)) {
                    return new PasteType() {
                        @Override
                        public Transferable paste() throws IOException {
//                            try {
//                                hierarchyFactory.add((HierarchyType) t.getTransferData(HierarchyFlavor.HIERARCHY_FLAVOR));
//                                final Node node = NodeTransfer.node(t, NodeTransfer.DND_MOVE + NodeTransfer.CLIPBOARD_CUT);
//                                if (node != null) {
//                                    node.destroy();
//                                }
//
//                            } catch (UnsupportedFlavorException ex) {
//                                Exceptions.printStackTrace(ex);
//                            }
                            return null;
                        }
                    };
                } else {
                    return null;
                }
            }
        }
    }
}
